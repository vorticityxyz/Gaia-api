# Description:
# 
# This example uses Vorticity gaia API's ertm18abc operator to run a reverse time
# migration model (RTM) using the fully elastic wave equations. The operator takes in 
# a p-velocity, s-velocity and density model + a elastic velocty based shot record to 
# return two gradient fields (vp and vs) which can be used as is or used as an update during an 
# full waveform inverstion (FWI) project. In this example a cross section of the gradient
# fields are plotted using matplotlib.
#
# Input parameters for the operator is generated by the function generate_test_data() 
# and is as follows:
#
# background vp - 3D numpy array representing the current p-velocity model
# background vs - 3D numpy array representing the current s-velocity model
# background rho - 3D numpy array representing the current density model
# shot - 1D numpy array representing the shot profile spanning the all timesteps
# vx shot record - 3D numpy array representing the x velocity receiver traces for model update
# vy shot record - 3D numpy array representing the y velocity receiver traces for model update
# vz shot record - 3D numpy array representing the z velocity receiver traces for model update
# shotxyz - Cartesian coordinates of the shot location
# recxxyyz - Cartesian coordinates of the receiver locations
# deltas - dx, dy, dz and dt for the simulation
# abc - width and amplitude of the absorbing boundary layer (absorbing sponge)
#
# Output: p-velocity and s-velocity gradient field (3D numpy array)
# 
# (C) Vorticity Inc. Mountain View, CA 2021
# Licence: MIT

import numpy as np
from scipy import ndimage, misc
import matplotlib.pyplot as plt
from matplotlib import cm
import gaia
import sys

# Plot cross section of the gradient fields
def plot_ertm(dvp, dvs):
    nx = dvp.shape[0]
    ny = dvp.shape[1]
    nz = dvp.shape[2]

    vp_image = np.swapaxes(dvp[:, round(ny/2), :], 0, 1)
    vpxSection = ndimage.laplace(vp_image)
    vs_image = np.swapaxes(dvs[:, round(ny/2), :], 0, 1)
    vsxSection = ndimage.laplace(vs_image)

    fig = plt.figure(figsize=(15, 15))
    scale = np.max(vpxSection) / 8.0
    #extent = [0, 2, 2, 0]
    #extent = [0, 1, 1, 0]
    plot = plt.imshow(vpxSection, vmin=-scale, vmax=scale, cmap=cm.gray)
    plt.xlabel('X position')
    plt.ylabel('Z position')
    plt.show()

    fig = plt.figure(figsize=(15, 15))
    scale = np.max(vsxSection) / 8.0
    #extent = [0, 2, 2, 0]
    #extent = [0, 1, 1, 0]
    plot = plt.imshow(vsxSection, vmin=-scale, vmax=scale, cmap=cm.gray)
    plt.xlabel('X position')
    plt.ylabel('Z position')
    plt.show()

# Generate shot profile
def generate_ricker(nt, freq, dt):
    max_amplitude = 1
    npt = nt * dt
    t = np.arange(-float(npt)/2, float(npt)/2, dt)
    # generate the short waveform
    rick1 = max_amplitude * (1 - t * t * freq**2 * np.pi**2) * np.exp(-t**2 * np.pi**2 * freq**2)
    # Overlay the short waveform over the full length of timesteps
    rick = np.zeros(nt, dtype=np.float32)
    rick[0: nt - (round(nt/2) - round(1/freq/dt) + 1)] = rick1[round(nt/2) - round(1/freq/dt) + 1: nt];
    return rick

def generate_elastic_data():
    # Earth model dimensions
    nx = 501
    ny = nx
    nz = nx

    # temporal discretization
    dt = 0.0002 #0.0001333333333

    # Spacial discretization
    dx = 1.0
    dy = dx
    dz = dx

    # number of timesteps
    nt = 2000

    # Shot parameters
    freq = 50.0
    xs = round(nx/2)
    ys = round(ny/2)
    zs = 4

    # Absorbing boundary conditions
    abcw = 50
    abca = 8        # alpha * 1000

    # Receiver setup
    xt1 = 54
    xt2 = (nx - 55)
    yt1 = round(nx/2)
    yt2 = round(nx/2)
    zt = 4

    # Earth model setup
    c1 = 1500
    c2 = 2000

    # Build earth and background models
    vp = np.full((nx, ny, nz), c1, dtype=np.float32)
    vs = np.full((nx, ny, nz), (c1/2), dtype=np.float32)
    vpb = np.full((nx, ny, nz), c1, dtype=np.float32)
    vsb = np.full((nx, ny, nz), (c1/2), dtype=np.float32)
    rho = np.full((nx, ny, nz), 1.0, dtype=np.float32)

    # Insert step to the earth models
    vp[:, :, 151:] = c2
    vs[:, :, 151:] = (c2/2)

    shot = generate_ricker(nt, freq, dt)
    shotxyz = np.array([xs, ys, zs], dtype=np.int32)
    recxxyyz = np.array([xt1, xt2, yt1, yt2, zt], dtype=np.int32)
    deltas = np.array([dx, dy, dz, dt], dtype=np.float32)
    abc = np.array([abcw, abca], dtype=np.int32)

    return vp, vs, vpb, vsb, rho, shot, shotxyz, recxxyyz, deltas, abc

if __name__ == '__main__':

    print("Generating elastic test data...")    
    vp, vs, vpb, vsb, rho, shot, shotxyz, recxxyyz, deltas, abc = generate_elastic_data()

    # Generate forward model data from scratch
    # vx, vy, vz = gaia.ef18abc(vp, vs, rho, shot, shotxyz, recxxyyz, deltas, abc)
    # Or load synthetic data from file (previous sim)
    with np.load("data/e_traces.npz") as data:
        vx = data['vx']
        vy = data['vy']
        vz = data['vz']

    # Run background forward model
    vxb, vyb, vzb = gaia.ef18abc(vpb, vsb, rho, shot, shotxyz, recxxyyz, deltas, abc)

    # Subtract the shot records to get the pure reflections (i.e remove direct arrivals)
    vx_res = vx - vxb
    vy_res = vy - vyb
    vz_res = vz - vzb

    # Call the gaia ertm operator
    dvp, dvs = gaia.ertm18abc(vpb, vsb, rho, shot, vx_res, vy_res, vz_res, shotxyz, recxxyyz, deltas, abc)

    # Save/Load the file if needed
    # np.savez("data/ertm.npz", dvp=dvp, dvs=dvs)
    # with np.load("data/ertm.npz") as data:
    #     dvp = data['dvp']
    #     dvs = data['dvs']

    # Plot results
    plot_ertm(dvp, dvs)

    